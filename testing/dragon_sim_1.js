"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var NUM_DRAGONS = 3; // count of dragons (players)
var NUM_KINGDOMS = 5; // count of populated kingdoms
var START_SHEEP = 3; // number of sheep each kindgom starts with
var NUM_FEAST = 4; // kingdoms that get a feast each round
var NUM_FAMINE = 2; // kingdoms that get a famine each round
var FEAST_FACTOR = 1; // sheep generated by each pair in a feast cycle
var FAMINE_FACTOR = 2; // ratio of sheep lost in a famine (1:x)
;
var Mode;
(function (Mode) {
    Mode["hunting"] = "HUNTING";
    Mode["sneaking"] = "SNEAKING";
    Mode["warpath"] = "WARPATH";
})(Mode || (Mode = {}));
;
var BASE_KINGDOM = {
    sheep: START_SHEEP
};
var BASE_DRAGON = {
    sheep: 0,
    location: null,
    mode: null
};
/**
 * create some kingdoms full of sheep
 * @param   numKingdoms the count of kingdoms this game will use
 * @return  Kingdom[]   an array of Kingdom objects
 */
function generateKingdoms(numKingdoms) {
    var kingdoms = [];
    for (var i = 0; i < numKingdoms; i++)
        kingdoms[i] = __assign({ index: i }, BASE_KINGDOM);
    return kingdoms;
}
/**
 * @param   numDragons  the number of dragons to use in this game
 * @return  Dragon[]    an array of dragon objects
 */
function generateDragons(numDragons) {
    var dragons = [];
    for (var i = 0; i < numDragons; i++)
        dragons[i] = __assign({ index: i }, BASE_DRAGON);
    return dragons;
}
/**
 * Provides either a Feast or Famine cycle to random kingdoms
 * Feast adds sheep and possibly Georges
 * Famine removes sheep
 * @param kingdoms  an array of the kingdoms
 * @param numFeast  the number of kingdoms to pick for Feast
 * @param numFamine the number of kingdoms to pick for Famine
 */
function runFeastAndFamineCycle(kingdoms, numFeast, numFamine) {
    // build arrays to hold the feast and famine selections
    var feastList = [], famineList = [];
    // pick some kingdoms to receive a feast
    while (feastList.length < numFeast) {
        var chosen = Math.floor(Math.random() * kingdoms.length);
        if (feastList.indexOf(chosen) === -1)
            feastList.push(chosen);
    }
    // pick some kingdoms to receive a famine
    while (famineList.length < numFamine) {
        var chosen = Math.floor(Math.random() * kingdoms.length);
        if (famineList.indexOf(chosen) === -1)
            famineList.push(chosen);
    }
    // check to see if feasts and famines overlap
    // kingdoms chosen for both feast and famine cancel out both effects
    var intersect = feastList.filter(function (i) { return famineList.indexOf(i) > -1; });
    intersect.forEach(function (i) {
        var pos1 = feastList.indexOf(i);
        feastList.splice(pos1, 1);
        var pos2 = famineList.indexOf(i);
        famineList.splice(pos2, 1);
    });
    // provide feasts to the kingdoms that receive them
    feastList.forEach(function (i) {
        // only kingdoms with at least 2 sheep get the benefits of feast
        if (kingdoms[i].sheep > 1) {
            kingdoms[i].sheep += (Math.floor(kingdoms[i].sheep / 2) * FEAST_FACTOR);
        }
    });
    // any kingdom with at least 1 sheep can lose sheep in a famine
    famineList.forEach(function (i) {
        if (kingdoms[i].sheep > 0) {
            kingdoms[i].sheep -= Math.floor((kingdoms[i].sheep + 1) / FAMINE_FACTOR);
        }
    });
    // kingdoms that get both feast and famine do not change the number of sheep they have,
    // but secondary feast and famine effects may still be enacted
    // Some Feasts also add Georges
    /*
    intersect.forEach(i => {
      // TODO: add secondary feast and famine effects
    });
    */
    // tell me what just happened
    console.log("Kingdom(s) ".concat(JSON.stringify(feastList), " received FEAST, and kingdom(s) ").concat(JSON.stringify(famineList), " endured FAMINE."));
    if (intersect.length > 0) {
        console.log("Kingdom(s) ".concat(JSON.stringify(intersect), " got FEAST & FAMINE"));
    }
}
/**
 * runs the kingdom choosing routine, where dragons pick kingdoms to hunt
 * @param kingdoms  an array holding all the kingdoms
 * @param dragon    the dragon doing the hunting
 */
function runChooseKingdomAndHuntMode(kingdoms, dragons, startDragon) {
    // this helper is how a dragon decides if a kingdom is an acceptable hunting location
    function acceptKingdom(newLocation) {
        // use the following rubric:
        var isAcceptable = true;
        // right now it's extremely simple: does the kingdom have sheep?
        if (kingdoms[newLocation].sheep === 0)
            isAcceptable = false;
        // TODO: add distance, sheep count, and dragon_count to the rubric
        // return the decision
        return isAcceptable;
    }
    // have each dragon choose where it's going to go and what it's going to do
    for (var turn = 0; turn < dragons.length; turn++) {
        var dragon = dragons[startDragon];
        // initially, the dragon's location and mode are reset
        dragon.location = null;
        dragon.mode = null;
        // sets the dragon's location to the first acceptable choice found
        // and it's mode to hunting
        while (dragon.location === null) {
            var newLocation = Math.floor(Math.random() * kingdoms.length);
            if (acceptKingdom(newLocation)) {
                dragon.location = newLocation;
                dragon.mode = Mode.hunting;
            }
        }
        startDragon = (startDragon + 1) % dragons.length;
    }
}
/**
 * runs the dragon feeding cycle, where each dragons take sheep based on location and mode
 * @param kingdoms  an array holding all the kingdoms
 * @param dragons   an array holding all the dragons
 */
function runDragonFeedingCycle(kingdoms, dragons, startDragon) {
    // initially, all dragons only hunt, which means they share
    // show me the dragon bellies (initially all zero)
    var bellies = dragons.map(function (dragon) { return 0; });
    var change = true;
    var _loop_1 = function () {
        var preFeeding = JSON.parse(JSON.stringify(bellies));
        // give each dragon 1 turn
        for (var dragonNumber = 0; dragonNumber < dragons.length; dragonNumber++) {
            var currentKingdom = dragons[startDragon].location;
            if (bellies[dragonNumber] === 0 && kingdoms[currentKingdom].sheep > 0) {
                // this dragon hasn't fed. It must eat.
                bellies[dragonNumber]++;
                kingdoms[currentKingdom].sheep--;
                //console.log(`dragon ${dragonNumber} hunted in kingdom ${currentKingdom}`);
            }
            else if (bellies[dragonNumber] > 0 && kingdoms[currentKingdom].sheep > 2) {
                // this dragon would like to eat and there appears to be plenty available
                bellies[dragonNumber]++;
                kingdoms[currentKingdom].sheep--;
                //console.log(`dragon ${dragonNumber} hunted in kingdom ${currentKingdom}`);
            }
            else if (bellies[dragonNumber] > 0 && kingdoms[currentKingdom].sheep === 1) {
                // this kingdom is depleted anyway, so might as well take the last sheep
                bellies[dragonNumber]++;
                kingdoms[currentKingdom].sheep--;
                //console.log(`dragon ${dragonNumber} hunted in kingdom ${currentKingdom}`);
            }
            else if (kingdoms[currentKingdom].sheep === 0) {
                //console.log(`dragon ${dragonNumber} could not find food in kingdom ${currentKingdom}`);
            }
            else {
                // this dragon has already fed and the kingdom barely has any sheep
                //console.log(`dragon ${dragonNumber} with belly ${bellies[dragonNumber]} chose not to feed in Kingdom ${currentKingdom} with ${kingdoms[currentKingdom].sheep} sheep`);
            }
            // go to the next dragon
            startDragon = (startDragon + 1) % dragons.length;
        }
        // see if the bellies have changed
        change = bellies.reduce(function (prev, belly, index) {
            if (belly !== preFeeding[index])
                return true;
            return prev;
        }, false);
    };
    do {
        _loop_1();
    } while (change === true);
    //console.log(`All dragons are done feeding`);
    //console.log();
    // now that the dragons have stopped feeding, update their sheep count
    dragons.forEach(function (dragon, index) {
        dragon.sheep += bellies[index];
    });
}
/**
 * this runs a single simulation of the dragon game
 */
function playGame() {
    console.log();
    console.log('***STARING GAME***');
    // start with the base kingdoms and dragons
    var kingdoms = generateKingdoms(NUM_KINGDOMS);
    var dragons = generateDragons(NUM_DRAGONS);
    // let the dragons fly around and get sheep
    // dragon 0 is always starts as first player, but each round first player shifts
    var startDragon = 0;
    for (var round = 0; round < 100; round++) {
        console.log();
        console.log("round ".concat(round, ".  Starting dragon is ").concat(startDragon));
        // pick a kingdom and a hunt mode for each dragon
        runChooseKingdomAndHuntMode(kingdoms, dragons, startDragon);
        // now that all dragons have chosen a location, run a feast and famine cycle
        runFeastAndFamineCycle(kingdoms, NUM_FEAST, NUM_FAMINE);
        // the dragon feed cycle
        runDragonFeedingCycle(kingdoms, dragons, startDragon);
        var sheep = kingdoms.reduce(function (agg, kingdom) { return agg + kingdom.sheep; }, 0) / kingdoms.length;
        // show me the game
        console.log("The dragons after feeding:");
        console.log(dragons);
        console.log("The Kingdoms after feeding:");
        console.log(kingdoms);
        console.log("average sheep: ".concat(sheep));
        // this makes sure there are any sheep to eat at all
        var totalSheep = kingdoms.reduce(function (agg, kingdom) { return agg + kingdom.sheep; }, 0);
        if (totalSheep === 0) {
            console.log('Extinction Event');
            break;
        }
        // shift the first player by one each round
        startDragon = (startDragon + 1) % dragons.length;
    }
}
;
playGame();
