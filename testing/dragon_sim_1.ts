const NUM_DRAGONS = 3;    // count of dragons (players)
const NUM_KINGDOMS = 5;   // count of populated kingdoms
const START_SHEEP = 3;    // number of sheep each kindgom starts with
const NUM_FEAST = 4;      // kingdoms that get a feast each round
const NUM_FAMINE = 2;     // kingdoms that get a famine each round
const FEAST_FACTOR = 1;   // sheep generated by each pair in a feast cycle
const FAMINE_FACTOR = 2;  // ratio of sheep lost in a famine (1:x)

interface Kingdom {
  index: number;
  sheep: number;
};

enum Mode {
  hunting = 'HUNTING',
  sneaking = 'SNEAKING',
  warpath = 'WARPATH'
}

interface Dragon {
  index: number;
  sheep: number;
  location: number | null;
  mode: Mode | null;
};

const BASE_KINGDOM = {
  sheep: START_SHEEP
};

const BASE_DRAGON = {
  sheep: 0,
  location: null,
  mode: null
};


/**
 * create some kingdoms full of sheep
 * @param   numKingdoms the count of kingdoms this game will use
 * @return  Kingdom[]   an array of Kingdom objects
 */
function generateKingdoms (
  numKingdoms:number
) : Kingdom[] {
  let kingdoms : Kingdom[] = [];
  for (let i=0; i<numKingdoms; i++) kingdoms[i] = { index: i, ...BASE_KINGDOM }
  return kingdoms;
}


/**
 * @param   numDragons  the number of dragons to use in this game
 * @return  Dragon[]    an array of dragon objects
 */
function generateDragons (
  numDragons:number
) : Dragon[] {
  let dragons : Dragon[] = [];
  for (let i=0; i<numDragons; i++) dragons[i] = { index: i, ...BASE_DRAGON };
  return dragons;
}


/**
 * Provides either a Feast or Famine cycle to random kingdoms
 * Feast adds sheep and possibly Georges
 * Famine removes sheep
 * @param kingdoms  an array of the kingdoms
 * @param numFeast  the number of kingdoms to pick for Feast
 * @param numFamine the number of kingdoms to pick for Famine
 */
function runFeastAndFamineCycle (
  kingdoms: Kingdom[],
  numFeast: number,
  numFamine: number
) : void {
  // build arrays to hold the feast and famine selections
  let feastList : number[] = [], famineList: number[] = [];

  // pick some kingdoms to receive a feast
  while (feastList.length < numFeast) {
    let chosen = Math.floor(Math.random()*kingdoms.length);
    if (feastList.indexOf(chosen)===-1) feastList.push(chosen);
  }

  // pick some kingdoms to receive a famine
  while (famineList.length < numFamine) {
    let chosen = Math.floor(Math.random()*kingdoms.length);
    if (famineList.indexOf(chosen)===-1) famineList.push(chosen);
  }

  // check to see if feasts and famines overlap
  // kingdoms chosen for both feast and famine cancel out both effects
  let intersect : number[] = feastList.filter(i => famineList.indexOf(i)>-1);
  intersect.forEach(i => {
    let pos1 = feastList.indexOf(i);
    feastList.splice(pos1,1);
    let pos2 = famineList.indexOf(i);
    famineList.splice(pos2,1);
  });
  
  // provide feasts to the kingdoms that receive them
  feastList.forEach(i => {
    // only kingdoms with at least 2 sheep get the benefits of feast
    if (kingdoms[i].sheep>1) {
      kingdoms[i].sheep += (Math.floor(kingdoms[i].sheep/2) * FEAST_FACTOR);
    }
  });

  // any kingdom with at least 1 sheep can lose sheep in a famine
  famineList.forEach(i => {
    if (kingdoms[i].sheep>0) {
      kingdoms[i].sheep -= Math.floor((kingdoms[i].sheep+1)/FAMINE_FACTOR);
    }
  });

  // kingdoms that get both feast and famine do not change the number of sheep they have,
  // but secondary feast and famine effects may still be enacted
  // Some Feasts also add Georges
  /*
  intersect.forEach(i => {
    // TODO: add secondary feast and famine effects
  });
  */

  // tell me what just happened
  console.log(`Kingdom(s) ${JSON.stringify(feastList)} received FEAST, and kingdom(s) ${JSON.stringify(famineList)} endured FAMINE.`);
  if (intersect.length>0) {
    console.log(`Kingdom(s) ${JSON.stringify(intersect)} got FEAST & FAMINE`);
  }
}

/**
 * runs the kingdom choosing routine, where dragons pick kingdoms to hunt
 * @param kingdoms  an array holding all the kingdoms
 * @param dragon    the dragon doing the hunting
 */
function runChooseKingdomAndHuntMode (
  kingdoms: Kingdom[],
  dragons: Dragon[],
  startDragon
) : void {
  // this helper is how a dragon decides if a kingdom is an acceptable hunting location
  function acceptKingdom (newLocation) : boolean {
    // use the following rubric:
    let isAcceptable = true;

    // right now it's extremely simple: does the kingdom have sheep?
    if (kingdoms[newLocation].sheep===0) isAcceptable = false;

    // TODO: add distance, sheep count, and dragon_count to the rubric

    // return the decision
    return isAcceptable;
  }

  // have each dragon choose where it's going to go and what it's going to do
  for (let turn=0; turn<dragons.length; turn++) {
    let dragon = dragons[startDragon];

    // initially, the dragon's location and mode are reset
    dragon.location = null;
    dragon.mode = null;

    // sets the dragon's location to the first acceptable choice found
    // and it's mode to hunting
    while (dragon.location===null) {
      let newLocation = Math.floor(Math.random()*kingdoms.length);
      if (acceptKingdom(newLocation)) {
        dragon.location = newLocation;
        dragon.mode = Mode.hunting;
      }
    }

    startDragon = (startDragon + 1) % dragons.length;
  }
}


/**
 * runs the dragon feeding cycle, where each dragons take sheep based on location and mode
 * @param kingdoms  an array holding all the kingdoms
 * @param dragons   an array holding all the dragons
 */
function runDragonFeedingCycle (
  kingdoms: Kingdom[],
  dragons: Dragon[],
  startDragon: number
) : void {
  // initially, all dragons only hunt, which means they share

  // show me the dragon bellies (initially all zero)
  let bellies = dragons.map(dragon => 0);
  let change = true;
  do {
    let preFeeding = JSON.parse(JSON.stringify(bellies));

    // give each dragon 1 turn
    for (let dragonNumber=0; dragonNumber<dragons.length; dragonNumber++) {
      let currentKingdom = dragons[startDragon].location;

      if (bellies[dragonNumber]===0 && kingdoms[currentKingdom].sheep>0) {
        // this dragon hasn't fed. It must eat.
        bellies[dragonNumber]++;
        kingdoms[currentKingdom].sheep--;
        //console.log(`dragon ${dragonNumber} hunted in kingdom ${currentKingdom}`);
      } else if (bellies[dragonNumber]>0 && kingdoms[currentKingdom].sheep>2) {
        // this dragon would like to eat and there appears to be plenty available
        bellies[dragonNumber]++;
        kingdoms[currentKingdom].sheep--;
        //console.log(`dragon ${dragonNumber} hunted in kingdom ${currentKingdom}`);
      } else if (bellies[dragonNumber]>0 && kingdoms[currentKingdom].sheep===1) {
        // this kingdom is depleted anyway, so might as well take the last sheep
        bellies[dragonNumber]++;
        kingdoms[currentKingdom].sheep--;
        //console.log(`dragon ${dragonNumber} hunted in kingdom ${currentKingdom}`);
      } else if (kingdoms[currentKingdom].sheep===0) {
        //console.log(`dragon ${dragonNumber} could not find food in kingdom ${currentKingdom}`);
      } else {
        // this dragon has already fed and the kingdom barely has any sheep
        //console.log(`dragon ${dragonNumber} with belly ${bellies[dragonNumber]} chose not to feed in Kingdom ${currentKingdom} with ${kingdoms[currentKingdom].sheep} sheep`);
      }

      // go to the next dragon
      startDragon = (startDragon + 1) % dragons.length
    }

    // see if the bellies have changed
    change = bellies.reduce((prev,belly,index) => {
      if (belly!==preFeeding[index]) return true;
      return prev;
    },false);

  } while (change===true);
  //console.log(`All dragons are done feeding`);
  //console.log();

  // now that the dragons have stopped feeding, update their sheep count
  dragons.forEach((dragon,index) => {
    dragon.sheep += bellies[index];
  });

}

/**
 * this runs a single simulation of the dragon game
 */
function playGame () : void {

  console.log();
  console.log('***STARING GAME***');

  // start with the base kingdoms and dragons
  let kingdoms = generateKingdoms(NUM_KINGDOMS);
  let dragons = generateDragons(NUM_DRAGONS);

  // let the dragons fly around and get sheep
  // dragon 0 is always starts as first player, but each round first player shifts
  let startDragon = 0;
  for (let round=0; round<100; round++) {

    console.log();
    console.log(`round ${round}.  Starting dragon is ${startDragon}`)

    // pick a kingdom and a hunt mode for each dragon
    runChooseKingdomAndHuntMode(kingdoms,dragons,startDragon);

    // now that all dragons have chosen a location, run a feast and famine cycle
    runFeastAndFamineCycle(kingdoms,NUM_FEAST,NUM_FAMINE);

    // the dragon feed cycle
    runDragonFeedingCycle(kingdoms,dragons,startDragon);
    
    let sheep = kingdoms.reduce((agg,kingdom) => agg+kingdom.sheep,0) / kingdoms.length;

    // show me the game
    console.log(`The dragons after feeding:`)
    console.log(dragons);
    console.log(`The Kingdoms after feeding:`);
    console.log(kingdoms);
    console.log(`average sheep: ${sheep}`)

    // this makes sure there are any sheep to eat at all
    let totalSheep = kingdoms.reduce((agg,kingdom) => agg+kingdom.sheep,0);
    if (totalSheep===0) {
      console.log('Extinction Event');
      break;
    }

    // shift the first player by one each round
    startDragon = (startDragon + 1) % dragons.length;
  }
};

playGame();

export {};